"""Vulnerability analysis tools integration"""

import subprocess
import json
import os
from typing import Dict, Any, Optional
from src.utils.kali_tools import KaliToolsManager

class VulnerabilityAnalysis:
    """Vulnerability analysis tools"""
    
    def __init__(self):
        """Initialize vulnerability analysis tools"""
        self.required_tools = [
            # Vulnerability Scanners
            'nmap', 'nikto', 'openvas', 'nessus', 'nexpose', 
            
            # Web Vulnerability Scanners
            'w3af', 'zaproxy', 'burpsuite', 'acunetix', 
            
            # Network Vulnerability Scanners
            'netcat', 'masscan', 'unicornscan', 'angry-ip-scanner', 
            
            # Exploitation Frameworks
            'metasploit', 'beef', 'sqlmap', 'commix', 
            
            # SSL/TLS Scanners
            'sslyze', 'testssl.sh', 'sslscan', 
            
            # Wireless Vulnerability Scanners
            'aircrack-ng', 'kismet', 'wifite', 
            
            # Additional Tools
            'enum4linux', 'smbmap', 'crackmapexec', 'legion', 
            'sparta', 'recon-ng', 'theHarvester'
        ]
        self._check_required_tools()
        
    def _check_required_tools(self):
        """Check required vulnerability analysis tools"""
        missing_tools = []
        
        for tool in self.required_tools:
            try:
                result = subprocess.run(['which', tool], capture_output=True, text=True)
                if result.returncode != 0:
                    missing_tools.append(tool)
            except Exception:
                missing_tools.append(tool)
        
        if missing_tools:
            print(f"[yellow]Missing vulnerability analysis tools: {', '.join(missing_tools)}[/yellow]")
            print("[yellow]Some vulnerability scanning features may be limited.[/yellow]")
            print("[yellow]Run the tool installer from the main menu to install missing tools.[/yellow]")
            
    def run_vuln_scan(self, target: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """Run vulnerability scan using nmap scripts"""
        if not self._check_tool('nmap'):
            return {'error': 'Nmap is not installed. Please install it first.'}
            
        try:
            # Default scan parameters for vulnerability detection
            scan_params = {
                'vuln': '--script vuln',  # Run vulnerability detection scripts
                'version': '-sV',         # Version detection
                'aggressive': '-A',       # Aggressive scan
                'timing': '-T4'          # Timing template (0-5)
            }
            
            # Update with custom parameters if provided
            if params:
                scan_params.update(params)
                
            # Build nmap command
            cmd = ['nmap']
            for param in scan_params.values():
                cmd.extend(param.split())
            cmd.append(target)
            
            # Run nmap scan
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode != 0:
                return {'error': f'Vulnerability scan failed: {result.stderr}'}
                
            return {
                'output': result.stdout,
                'command': ' '.join(cmd)
            }
            
        except Exception as e:
            return {'error': f'Error running vulnerability scan: {str(e)}'}
            
    def run_scan(self, target: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """Alias for run_vuln_scan to maintain compatibility with menu system"""
        return self.run_vuln_scan(target, params)
            
    def run_sqlmap(self, target: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """Run SQLMap for SQL injection testing"""
        if not self._check_tool('sqlmap'):
            return {'error': 'SQLMap is not installed. Please install it first.'}
            
        try:
            # Default SQLMap parameters
            sqlmap_params = {
                'batch': '--batch',           # Non-interactive mode
                'random-agent': '--random-agent',  # Use random User-Agent
                'risk': '--risk=2',           # Risk level
                'level': '--level=2'          # Level of tests
            }
            
            # Update with custom parameters if provided
            if params:
                sqlmap_params.update(params)
                
            # Build sqlmap command
            cmd = ['sqlmap', '-u', target]
            for param in sqlmap_params.values():
                cmd.extend(param.split())
                
            # Run sqlmap
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode != 0:
                return {'error': f'SQLMap scan failed: {result.stderr}'}
                
            return {
                'output': result.stdout,
                'command': ' '.join(cmd)
            }
            
        except Exception as e:
            return {'error': f'Error running SQLMap: {str(e)}'}
            
    def run_metasploit(self, target: str, exploit: str = None) -> Dict[str, Any]:
        """Run Metasploit Framework"""
        if not self._check_tool('metasploit'):
            return {'error': 'Metasploit is not installed. Please install it first.'}
            
        try:
            # Create resource script
            script_content = f"""
use auxiliary/scanner/portscan/tcp
set RHOSTS {target}
run
"""
            if exploit:
                script_content += f"""
use {exploit}
set RHOSTS {target}
show options
"""
            
            # Save resource script
            script_path = os.path.join(os.getcwd(), 'msf_script.rc')
            with open(script_path, 'w') as f:
                f.write(script_content)
                
            # Run metasploit with resource script
            cmd = ['msfconsole', '-q', '-r', script_path]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            # Clean up resource script
            os.remove(script_path)
            
            if result.returncode != 0:
                return {'error': f'Metasploit scan failed: {result.stderr}'}
                
            return {
                'output': result.stdout,
                'command': ' '.join(cmd)
            }
            
        except Exception as e:
            return {'error': f'Error running Metasploit: {str(e)}'}

    def run_database_assessment(self, tool: str, target: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Run database assessment tools
        
        :param tool: Name of the database assessment tool to use
        :param target: Target database or file
        :param params: Additional parameters for the tool
        :return: Dictionary with assessment results
        """
        if not self._check_tool(tool):
            return {'error': f'{tool} is not installed. Please install it first.'}
        
        try:
            # Default parameters for database assessment tools
            assessment_params = {
                'sqlmap': ['sqlmap', '-u', target, '--dbs', '--batch'],
                'sqlitebrowser': ['sqlitebrowser', target]
            }
            
            # Customize command if additional parameters are provided
            cmd = assessment_params.get(tool, [tool, target])
            if params:
                for key, value in params.items():
                    cmd.extend([key, str(value)])
            
            # Run the database assessment tool
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            return {
                'status': 'Database assessment completed',
                'tool': tool,
                'target': target,
                'stdout': result.stdout,
                'stderr': result.stderr
            }
        
        except subprocess.TimeoutExpired:
            return {'error': f'Database assessment with {tool} timed out'}
        except Exception as e:
            return {'error': f'Database assessment failed: {str(e)}'}

    def run_voip_tools(self, target: str, tool: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Run VoIP-related vulnerability analysis tools
        
        :param target: Target IP or domain
        :param tool: VoIP tool to run (legion, nikto, nmap, unix_privesec_check, zenmap)
        :param params: Additional parameters for the tool
        :return: Dictionary with scan results or error
        """
        if not target:
            return {'error': 'Target is required'}
        
        # Validate tool selection
        voip_tools = ['legion', 'nikto', 'nmap', 'unix_privesec_check', 'zenmap']
        if tool not in voip_tools:
            return {'error': f'Invalid VoIP tool. Choose from {", ".join(voip_tools)}'}
        
        try:
            # Tool-specific scanning logic
            if tool == 'legion':
                # Legion is a VoIP pentest tool
                cmd = f'legion -t {target}'
            
            elif tool == 'nikto':
                # Nikto web server scanner
                cmd = f'nikto -h {target}'
            
            elif tool == 'nmap':
                # Nmap VoIP-specific scripts
                cmd = f'nmap --script voip-* {target}'
            
            elif tool == 'unix_privesec_check':
                # Unix privilege escalation check
                cmd = f'unix_privesec_check {target}'
            
            elif tool == 'zenmap':
                # Zenmap (GUI for nmap)
                cmd = f'zenmap {target}'
            
            # Add custom parameters if provided
            if params and 'additional_args' in params:
                cmd += f' {params["additional_args"]}'
            
            # Execute the command
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            return {
                'tool': tool,
                'target': target,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'return_code': result.returncode
            }
        
        except Exception as e:
            return {'error': f'Error running {tool}: {str(e)}'}

    def run_fuzzing_tools(self, target: str, tool: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Run fuzzing tools for vulnerability analysis
        
        :param target: Target IP or domain
        :param tool: Fuzzing tool to run (generic_chunked, generic_listen_tcp, generic_send_tcp, generic_send_udp)
        :param params: Additional parameters for the tool
        :return: Dictionary with fuzzing results or error
        """
        if not target:
            return {'error': 'Target is required'}
        
        # Validate tool selection
        fuzzing_tools = ['generic_chunked', 'generic_listen_tcp', 'generic_send_tcp', 'generic_send_udp']
        if tool not in fuzzing_tools:
            return {'error': f'Invalid fuzzing tool. Choose from {", ".join(fuzzing_tools)}'}
        
        try:
            # Tool-specific fuzzing logic
            if tool == 'generic_chunked':
                cmd = f'generic_chunked {target}'
            
            elif tool == 'generic_listen_tcp':
                # Default to listening on a standard port if not specified
                port = params.get('port', 8080) if params else 8080
                cmd = f'generic_listen_tcp -p {port} {target}'
            
            elif tool == 'generic_send_tcp':
                # Require port and message in params
                if not params or 'port' not in params or 'message' not in params:
                    return {'error': 'For generic_send_tcp, provide port and message in params'}
                cmd = f'generic_send_tcp -p {params["port"]} -m "{params["message"]}" {target}'
            
            elif tool == 'generic_send_udp':
                # Require port and message in params
                if not params or 'port' not in params or 'message' not in params:
                    return {'error': 'For generic_send_udp, provide port and message in params'}
                cmd = f'generic_send_udp -p {params["port"]} -m "{params["message"]}" {target}'
            
            # Add custom parameters if provided
            if params and 'additional_args' in params:
                cmd += f' {params["additional_args"]}'
            
            # Execute the command
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            return {
                'tool': tool,
                'target': target,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'return_code': result.returncode
            }
        
        except Exception as e:
            return {'error': f'Error running {tool}: {str(e)}'}

    def run_vulnerability_tool(self, category: str, tool: str, target: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Unified method to run vulnerability analysis tools directly
        
        :param category: Category of tool (voip, fuzzing)
        :param tool: Specific tool to run
        :param target: Target IP or domain
        :param params: Additional parameters for the tool
        :return: Dictionary with tool results or error
        """
        try:
            # Validate category
            valid_categories = ['voip', 'fuzzing']
            if category.lower() not in valid_categories:
                return {'error': f'Invalid category. Choose from {", ".join(valid_categories)}'}
            
            # Route to appropriate method based on category
            if category.lower() == 'voip':
                return self.run_voip_tools(target, tool, params)
            
            elif category.lower() == 'fuzzing':
                return self.run_fuzzing_tools(target, tool, params)
        
        except Exception as e:
            return {'error': f'Error in vulnerability tool execution: {str(e)}'}
            
    def _check_tool(self, tool: str) -> bool:
        try:
            result = subprocess.run(['which', tool], capture_output=True, text=True)
            return result.returncode == 0
        except Exception:
            return False
