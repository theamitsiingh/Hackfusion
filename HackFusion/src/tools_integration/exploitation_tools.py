"""
Exploitation Tools module for HackFusion
Handles exploitation frameworks and tools
"""

import subprocess
from typing import Dict, List, Optional
import logging
import json
import os
import time

logger = logging.getLogger('HackFusion')

class ExploitationTools:
    def __init__(self, config: Dict):
        self.config = config
        self.tools = config.get('exploitation', {})
        self.msf_rpc = None

    def start_metasploit(self, workspace: str = "default") -> Dict:
        """
        Start Metasploit Framework console
        
        Args:
            workspace: Metasploit workspace name
        
        Returns:
            Dict containing operation status
        """
        if not self.tools.get('metasploit', {}).get('enabled'):
            return {'error': 'Metasploit Framework is not enabled'}

        try:
            # Start MSF console
            cmd = [
                'msfconsole',
                '-q',  # Quiet mode
                '-x', f'workspace {workspace}'  # Set workspace
            ]

            logger.info(f"Starting Metasploit Framework: {' '.join(cmd)}")
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE,
                text=True
            )

            return {
                'success': True,
                'pid': process.pid,
                'workspace': workspace
            }
        except Exception as e:
            logger.error(f"Error starting Metasploit: {str(e)}")
            return {'error': str(e)}

    def run_exploit(
        self,
        module: str,
        target: str,
        options: Dict[str, str],
        payload: Optional[str] = None
    ) -> Dict:
        """
        Run a Metasploit exploit
        
        Args:
            module: Exploit module path
            target: Target host/IP
            options: Dictionary of module options
            payload: Optional payload to use
        
        Returns:
            Dict containing exploit results
        """
        try:
            # Create resource script
            script_content = [
                f"use {module}",
                f"set RHOSTS {target}"
            ]

            for option, value in options.items():
                script_content.append(f"set {option} {value}")

            if payload:
                script_content.append(f"set PAYLOAD {payload}")

            script_content.append("exploit -j")  # Run in background

            script_path = os.path.join(os.getcwd(), 'msf_script.rc')
            with open(script_path, 'w') as f:
                f.write('\n'.join(script_content))

            # Run exploit
            cmd = [
                'msfconsole',
                '-q',
                '-r', script_path
            ]

            logger.info(f"Running Metasploit exploit: {module}")
            process = subprocess.run(cmd, capture_output=True, text=True)

            # Clean up script
            os.remove(script_path)

            return {
                'success': process.returncode == 0,
                'output': process.stdout,
                'error': process.stderr if process.returncode != 0 else None
            }
        except Exception as e:
            logger.error(f"Error running exploit: {str(e)}")
            return {'error': str(e)}

    def search_exploit_db(self, query: str) -> Dict:
        """
        Search ExploitDB database
        
        Args:
            query: Search query
        
        Returns:
            Dict containing search results
        """
        if not self.tools.get('exploitdb', {}).get('enabled'):
            return {'error': 'ExploitDB is not enabled'}

        try:
            cmd = ['searchsploit', '--json', query]
            
            logger.info(f"Searching ExploitDB: {query}")
            process = subprocess.run(cmd, capture_output=True, text=True)

            results = []
            if process.returncode == 0:
                try:
                    data = json.loads(process.stdout)
                    results = data.get('RESULTS_EXPLOIT', [])
                except json.JSONDecodeError:
                    logger.error("Failed to parse ExploitDB results")

            return {
                'success': process.returncode == 0,
                'results': results,
                'count': len(results),
                'error': process.stderr if process.returncode != 0 else None
            }
        except Exception as e:
            logger.error(f"Error searching ExploitDB: {str(e)}")
            return {'error': str(e)}

    def generate_payload(
        self,
        payload_type: str,
        options: Dict[str, str],
        output_format: str = 'raw',
        output_file: Optional[str] = None
    ) -> Dict:
        """
        Generate a payload using msfvenom
        
        Args:
            payload_type: Type of payload
            options: Dictionary of payload options
            output_format: Output format (raw, exe, python, etc.)
            output_file: Optional output file path
        
        Returns:
            Dict containing generated payload
        """
        try:
            cmd = ['msfvenom', '-p', payload_type]

            for option, value in options.items():
                cmd.extend(['-p', f'{option}={value}'])

            cmd.extend(['-f', output_format])

            if output_file:
                cmd.extend(['-o', output_file])

            logger.info(f"Generating payload: {' '.join(cmd)}")
            process = subprocess.run(cmd, capture_output=True)

            return {
                'success': process.returncode == 0,
                'output_file': output_file if output_file else None,
                'payload': process.stdout if not output_file else None,
                'error': process.stderr.decode() if process.returncode != 0 else None
            }
        except Exception as e:
            logger.error(f"Error generating payload: {str(e)}")
            return {'error': str(e)}
